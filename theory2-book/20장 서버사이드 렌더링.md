```js

0. 서버사이드 렌더링이란, 클라이언트 단에서 작업하던 View와 Controller를 서버에서 직접 작업하는 것이다.

클라이언트 사이드 렌더링은, 리액트로 뷰를 만들고, 각각 필요로 한 데이터를 서버 API에 요청하여 사용하는 방식으로, 클라이언트와 서버가 분리되어 가동되는 방식이다. 서버는 data요청을 받고 내보내는 역할만 한다.

서버사이드 렌더링은 클라이언트에서 하는 모든 작업을 서버에서 작업하여 뷰를 사용자에게 보여주는 방식이다. -> React의 SPA 특징을 가지면서도 server에서 온전한 html을 전달할 수 있는 방법을 제공해줌



1. 왜? 서버사이드 렌더링을 사용해야할까?

사실 기본 리액트는 index.html을 보면 알겠지만 시작할 때는 아예 비어있는 상태이고
자바스크립트 코드에 의해 컴포넌트 단위로 렌더링을 하고 AJAX 통신을 통해 서버로 부터 컨텐츠 내용을 받아오고나서야 클라이언트가 결과를 볼 수 있습니다.

위와 같은 방식을 따를 경우, 검색엔진에 의해 해당 웹페이지를 수집하기 어려울 것입니다. 크롤러가 해당 웹페이지의 컨텐츠 or 키워드를 수집하려고 할 때, 비어있는 화면을 보게 될 것이죠. 그리고 추가로 리액트 프로젝트자체가 사이즈가 작지 않기때문에 초기 로딩 시간이 더 길어질 것입니다.

여기서 생기는 문제점을 정리해보면 서버사이드 렌더링이 왜 필요한지 알 수 있습니다.

1) 우리 웹페이지를 검색 엔진에 노출시키기 위해서
2) 초기 렌더링 속도를 향상 시키기 위해서(최적화)



*** 서버 사이드 렌더링과 코드 스플리팅 충돌
- 서버사이드 렌더링과 코드 스플리팅을 함께 적용하면 작업이 꽤 까다로움. 별도의 호환 작업 없이 두 기술을 함께 적용하면 페이지에 깜빡임 발생
-> 맨앞에 SSR 의 결과가 나타나서 그런 것

1) 서버사이드렌더링된 결과물이 브라우저에 나타남
2) 자바스크립트 파일 로딩 시작
3) 자바스크립트가 실행되면서 아직 불러오지 않은 컴포넌트를 null로 렌더링함
4) 페이지에서 코드 스플리팅된 컴포넌트들이 사라짐
5) 코드 스플리팅된 컴포넌트들이 로딩된 이후 제대로 나타남

-> 이러한 이슈를 해결하려면 라우트 경로마다 코드 스플링된 파일 중에서 필요한 모든 파일을 브라우저에서 렌더링하기 전에 미리 불러와야함
==> lodable component라이브러리에서 제공하는 기능을 써서 서버사이드렌더링 후 필요한 파일의 경로를 추출하여 렌더링 결과에 스크립트/스타일 태그를 삽입해줌




3. 서버사이드 렌더링 구현하기

- 서버사이드 렌더링을 구현하려면 웹팩 설정을 커스터마이징 해주어야함
- yarn eject

1) 서버사이드 렌더링용 엔트리 만들기
- 엔트리는 웹팩에서 프로젝트를 불러올 떄 가장 먼저 불러오는 파일
- CSR 에서는 index.js가 담당
- SSR을 구현하려면 서버를 위한 엔트리 파일을 따로 생성해야함
- src/index.server.js 생성

import React from "react";
import ReactDOMServer from "react-dom/server";

const html = ReactDOMServer.renderToString(<div>Hello this is SSR!</div>);

console.log(html);

- 서버에서 리액트 컴포넌트를 렌더링할 때는 ReactDOMServer의 rendertoString()이라는 함수를 사용한다. 이 함수에 JSX를 넣어서 호출하면 렌더링 결과를 문자열로 반환


2) 서버사이드 렌더링 전용 웹팩 환경 설정 작성하기
- 작성한 엔트리 파일을 웹팩으로 불러와서 빌드하려면 서버 전용 환경 설정을 만들어 주어야 함
- /config/paths.js에 코드 추가

ssrIndexJs: resolveApp("src/index.server.js"), -> 서버사이드 렌더링 엔트리
ssrBuild: resolveApp("dist"), -> 웹팩 처리 후 결과물 저장 경로

- 다음으로 웹팩 환경 설정 파일 작성
- config/webpack.config.server.js 생성

- 1 -  기본설정 작성 : 빌드할 때 어떤 파일에서 시작해 파일들을 불러오는지, 또 어디에 결과물을 저장할지

- 2 -  로더 작성 : 웹팩의 로더는 파일을 불러올 때 확장자에 맞게 필요한 처리를 해준다. 예를 들어 JS 는 babel을 사용하여 트랜스파일링을 해주고, CSS 는 모든 CSS 코드를 결합해주고, 이미지 파일은 파일을 다른 경로에 따로 저장하고, 그파일에 대한 경로를 JS 에서 참조할 수 있게 해줌

- 3 - 코드에서 node_modules 내부의 라이브러리를 불러올 수 있게 설정 : 이렇게 했을 때 react, react-dom/server 같은 라이브러리를 import. 구문으로 불러오면 node_modules에서 찾아 사용한다. 라이브러리를 불러오면 빌드할 때 결과물 파일 안에 해당 라이브러리 관련 코드가 함께 번들링된다. 따라서 서버를 위해 번들링할 떄는 node_modules에서 불러오는 것을 제외하고 번들링하는 것이 좋다. -> webpack-node-externals라는 라이브러리 사용

- 4 - 환경변수 주입 : 환경변수를 주입하면 프로젝트 내에서 process.env.NODE_ENV 값을 참조하여 현재 개발환경인지 아닌지를 알 수 있다.

3) 빌드 스크립트 작성하기

- 위에서 만든 환경설정을 사용하여 웹팩으로 프로젝트를 빌드하는 스크립트를 작성해야함
- scripts/build.js 는 클라이언트에서 사용할 빌드 파일을 만드는 파일
- 서버에서 사용할 build.server.js 작성

4) package.json 작성

"scripts": {
        "start": "node scripts/start.js", -> 개발용(클라이언트)
        "build": "node scripts/build.js", -> 배포용(클라이언트)
        "test": "node scripts/test.js", -> 테스트용(클라이언트)
        "start:server": "node scripts/build.server.js" -> 개발용(서버)
        "build:server": "node scripts/build.server.js", -> 배포용(서버)
    },


5) 서버코드 작성하기

-> index.server.js에 작성




*****
React 서버 사이드 렌더링
React는 서버 사이드 렌더링을 염두에 두고 설계되었습니다.

ReactDOMServer.renderToString 함수는 서버 사이드에서 사용하는 렌더링 함수입니다. 이 함수는 HTML을 생성하는데 클라이언트에서 동적으로 생성하는 것과 동일한 HTML을 생성합니다. 다른점은 data-react-checksum과 같은 attribute가 추가되었다는 점입니다.

서버 사이드에서 생성된 HTML에는 이벤트 속성이 없기 때문에 반드시 ReactDOM.render()과 같은 클라이언트 사이드 렌더링을 다시 한번 수행해야 합니다.


두번 렌더링한다구요? 네.

두번째 렌더링을 할때 이미 서버 사이드 렌더링이 되어 있다면 attribute값을 보고 다시 렌더링 하지 않고 생성된 DOM에 오직 이벤트 속성만 추가합니다. checksum을 보고 판단하기 때문에 속도가 굉장히 빠릅니다.

이러한 부분이 이미 React는 서버 사이드 렌더링을 염두에 두고 설계되었다는 점입니다.
```
