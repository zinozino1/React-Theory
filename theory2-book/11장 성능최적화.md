```js

10장에 이어서

1. 성능 최적화를 하지 않으면 많은 수의 데이터를 렌더링 했을 때 대기 시간이 길어진다.
- bulkData로 테스팅

2. 크롬 개발자 도구를 통한 성능 모니터링
- 크롬 개발자 도구의 Performance 탭 -> 작업을 녹화 -> timings를 확인 -> 약 2500개의 데이터를 뿌렸을 때 0.95초가 걸렸음 (App 컴포넌트 업데이트) -> 성능이 매우 나쁨

3. 원인분석
- 컴포넌트가 리렌더링되는 경우는 4가지. 1) 자신이 전달받은 props가 변경될 때 2) 자신의 state가 바뀔때 3) 부모 컴포넌트가 리렌더링될 때 4) forceUpdate 함수가 실행될 때

4. React.memo를 사용하여 컴포넌트 성능 최적화
- 컴포넌트의 props가 바뀌지 않았다면 리렌더링 되지 않게 한다.
- 그렇다면 어떤 컴포넌트에서 React.memo를 사용해야 하는 것일까?
-> 렌더링 성능 저하는 TodoListItem 컴포넌트의 수많은 숫자(그 수많은 컴포넌트가 모두 리렌더링)에서 비롯됨.


****** 실전 ******
1) 성능 최적화를 하고 싶은 컴포넌트에 React.memo를 써준다.(우선 첫번째로 props의 변경에 관계없이 부모컴포넌트가 리렌더링 되면 자식도 리렌더링 되는 것을 방지) -> 부모로부터 전달되는 props가 변경되지 않는 이상 리렌더링 되지않음.

2) 다음은 부모로부터 전달되는 props변경을 최소화 해야한다. 필수적인 state 변경으로 인한 props 변경은 제외 하고, 부모 컴포넌트의 리렌더링으로 인한 부모 컴포넌트 내부 함수 재정의로 자식 컴포넌트의 props가 바뀌어서 리렌더링 되지 않게 useReducer, useCallback을 부모 컴포넌트 내부에서 적재적소에 잘 사용해야 함.

3) 작업을 할 때 모든 컴포넌트에 일일이 React.memo를 작성할 필요는 없으나 리스트와 관련된 컴포넌트를 만들 때 보여 줄 항목이 100개 이상이고 업데이트가 자주 발생한다면 최적화를 꼭 해주어야한다.


5. 불변성의 중요성

- 불변성이 지켜지지 않으면 React는 객체 내부의 값이 새로워져도 바뀐 것을 감지하지 못한다. 그러면 React.memo 를 사용했을 때 props가 바뀌었는지 혹은 바뀌지 않았는지를 알아낼 수 없다.

1) 배열의 경우
const arr = [1,2,3];
const newArr = [...arr];

2) 객체의 경우
const obj = {id: 1, text: "hi"};
const newObj = {...obj};

-> 전개 연산자를 사용할 경우 shallow copy가 되어서 객체나 배열 안까지 복사가 되지 않는다.

ex)
const objArr = [{id: 1, text: "hi"},{id: 2, text: "hi"} ];
const newObjArr = [...objArr]; ==> shallow copy가 되었음

해결 => newObjArr[0] = {...objArr[0]} 이런식으로 배열 요소마다 반복

==> 더 복잡한 구조일경우 불변성을 유지하기가 매우 까다롭다 ==> immer 라이브러리의 도움을 받아야함.


6. 렌더링 최적화 with react-virtualized
- 아직 화면에 보이지 않는 요소들을 렌더링하지 않고 크기만 차지하게끔 할 수 있는 라이브러리.
- 낭비되는 자원을 쉽게 아낄 수 있다.
- npm i react-virtualized


```
